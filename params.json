{"name":"Thing","body":"# What is Thing\r\n\r\nThing is a lightweight SQLAlchemy based ORM, powerful meanwhile flexible.\r\n\r\n# Why Thing\r\n\r\nI like ORM, it's the way programmers deal with database. I like ROR's active record, though not all all them. I want it can be easily configured to master / slave, sharding mode, has validator, easy to be integrated with cache. SO I create Thing.\r\n\r\n# Thing's Feature\r\n\r\n* master / slave mode can be easily configured, even sharding strategy can be easily implemented. \r\n* has hook before / after CRUD, so you can easily implement cache strategy.\r\n* blinker's signal is triggered before CUD, make your application more loose couple.\r\n* integrated an validator (via formencode)\r\n* support profile\r\n* support ROR's dynamic query, like find_by_user_id, count_by_status\r\n\r\n# Installation\r\n\r\n```\r\npip install thing\r\n```\r\n\r\n# Basic Usage\r\n\r\nsuppose we have an user table like this:\r\n\r\n```\r\nCREATE TABLE `user` (\r\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\r\n  `username` varchar(50) DEFAULT NULL,\r\n  `password` varchar(40) DEFAULT NULL,\r\n  UNIQUE KEY `username` (`username`)\r\n) ENGINE=InnoDB CHARSET=utf8\r\n```\r\n\r\n## define user model\r\n\r\n```\r\n#user.py\r\nimport thing\r\nclass User(thing.Thing):\r\n     pass\r\n\r\n\r\n#conn.py\r\nimport thing\r\n\r\ndb_config = {\r\n        'master': {\r\n            'url': 'mysql://username:password@127.0.0.1:3306/dbname?charset=utf8',\r\n            'echo': False,\r\n            },\r\n        'slave': {\r\n            'url': 'mysql://username:password@127.0.0.1:3306/dbname?charset=utf8',\r\n            'echo': False,\r\n            },\r\n    }\r\n\r\nthing.Thing.db_config(db_config)\r\n\r\n\r\n#main.py\r\nimport user\r\nimport conn\r\n\r\n# create user\r\nuser_id = user.User(\r\n    usernmae = 'foobar',\r\n    password = 'p@ssword',\r\n).save()\r\n\r\n# find user\r\ncurrent_user = user.User().find(user_id)\r\nprint current_user.username # 'foobar'\r\n\r\n# update user\r\ncurrent_user.username = 'test'\r\ncurrent_user.save()\r\nprint current_user.name # 'test'\r\n\r\n# delete user\r\nuser.User().find(user_id).delete()\r\n```\r\n\r\n# Advanced Usage\r\n\r\n## query\r\n\r\n```\r\nimport user\r\nimport conn\r\n\r\nsome_users = user.User().where('id', '<', 10).findall()\r\nprint len(some_users) # 9\r\nfor some_user in some_users:\r\n    print some_user.username\r\n\r\nsome_users = user.User().select(['id']).where('id', '<', 10).order_by('-id').findall(limit=5, offset=5)\r\n\r\nuser_ids = user.User().findall(limit=5).get_field('id') # [1, 2, 3, 4, 5]\r\n\r\nmax_user_id = user.User().select(['max(id) as max_id']).find().max_id\r\n```\r\n\r\n## update\r\n\r\n```\r\nimport user\r\nimport conn\r\n\r\nuser.User().where('id', '<', 10).updateall(username = 'foobar') # return 9 (affected rows)\r\n```\r\n\r\n## delete\r\n\r\n```\r\nimport user\r\nimport conn\r\n\r\nuser.User().where('id', '<', 5).delete() # return 4 (affected rows)\r\n```\r\n\r\n## raw sql\r\n\r\n```\r\nimport user\r\nimport conn\r\n\r\nuser.User().query('do some special query')\r\n```\r\n\r\n# Dynamic Method\r\n\r\nthere are 4 kind of dynamic method: `find_by_{fields}`, `findall_by_{fields}`, `findall_in_{field}`, `count_by_{fields}`\r\n\r\ni.e.\r\n\r\n```\r\nimport conn\r\nimport user\r\n\r\nuser.User().findall_in_id([1, 3, 5]) # find users whose id is 1, 3, 5\r\n\r\nuser.User().find_by_id_and_username(3, 'foobar') # find user whose id is 3 and username is foobar\r\n\r\nuser.User().count_by_id_and_username(4, 'john') # how many rows meets the condition: id = 4 and username = 'john'\r\n```\r\n\r\nborrowed from ROR, if you want to add cache, just implement the method you called, that's it, totally transparent.\r\n\r\n\r\n# Hooks\r\n\r\nthere are currently 8 hooks:\r\n\r\n* _before_insert\r\n* _after_insert\r\n* _before_update\r\n* _after_update\r\n* _before_delete\r\n* _after_delete\r\n* _before_find\r\n* _before_findall\r\n\r\nif we want to add cache for the find method in User model, just implement some hooks\r\n\r\n```\r\n#user.py\r\nimport thing\r\nimport redis\r\nimport json\r\n\r\nrc = redis.Redis()\r\n\r\nclass User(thing.Thing):\r\n    def _before_insert(self):\r\n        rc.set('user:{0}'.format(self.id), json.dumps(self.to_dict()))\r\n\r\n    def _before_update(self):\r\n        self._before_insert()\r\n\r\n    def _before_read(self):\r\n        user = rc.get('user:{0}')\r\n        if user:\r\n            return json.loads(user)\r\n```\r\n\r\n# Signal\r\n\r\nsuppose there are article and comment tables, article table has an field `comment_count`, so when a new comment added, article table should update its `comment_count` field. it can be done via signal.\r\n\r\nthere are 8 built in signals\r\n\r\n* model.before_validation\r\n* model.after_validation\r\n* model.before_insert\r\n* model.after_insert\r\n* model.before_update\r\n* model.after_update\r\n* model.before_delete\r\n* model.after_delete\r\n\r\n```\r\n#article.py\r\nfrom blinker import signal\r\nimport thing\r\n\r\ncomment_add = signal('comment.after_insert')\r\n\r\nclass Article(thing.Thing):\r\n    @comment_add.connect\r\n    def _comment_add(comment):\r\n        article = Article().find(comment.article_id)\r\n        article.comment_count += 1\r\n        article.save()\r\n\r\n#comment.py\r\nimport thing\r\n\r\nclass Comment(thing.Thing):\r\n    pass\r\n\r\n#trigger.py\r\nimport conn\r\nimport article, comment\r\n\r\ncomment.Comment(content = 'hello world').save()\r\n# that's it, article's `comment_count` field will be updated.\r\n```\r\n\r\n# validator\r\n\r\nvalidate is implemented via [formencode](http://www.formencode.org/en/latest/Validator.html)\r\n\r\nif we want to add some restrict to our User model's username field, it can be done like this:\r\n\r\n```\r\nimport thing\r\nclass User(thing.Thing):\r\n    username = formencode.All(\r\n            validators.String(\r\n                 not_empty = True,\r\n                 strip = True,\r\n                 min = 4,\r\n                 max = 24,\r\n                 messages = {\r\n                     'empty': u'please enter an username',\r\n                     'tooLong': u'username too long',\r\n                     'tooShort': u'username too short'}),\r\n             validators.PlainText(messages = {\r\n                     'invalid': u'username can only contain \"number\", \"_\", \"-\" and \"digit\"'\r\n                  }))\r\n\r\n# if we want to save with invalid username, it can not be saved\r\n\r\nuser = User()\r\nuser.username = '!@#$%^&'\r\nuser.save()\r\nprint user.saved # False\r\nprint user.errors # a dict contains error field and message\r\n```\r\n\r\nwith the help of formencode, the validator can be very flexible.\r\n\r\n# Profile\r\n\r\nsqlalchemy will print sql execution information if debug is set to True, but it is unreadable and not so detail.\r\n\r\n```\r\nimport thing\r\nimport user\r\n\r\nthing.Thing.enable_profile()\r\nuser.User().findall()\r\n# any other db related operation\r\nprint thing.Thing.get_sql_stats # a dict with total_time, query_count, and executed query\r\n```\r\n\r\n# Partition\r\n\r\nThing support master / slave natively. if you have do some vertical partition, and the partition has its own master / slave, it's OK. if you have domain related sharding strategy, just implement `sharding_strategy` method.\r\n\r\ntake this db_config as an example.\r\n\r\n```\r\ndb_config = {\r\n        'master': {\r\n            'url': 'mysql://username:password@127.0.0.1:3306/dbname?charset=utf8',\r\n            'echo': False,\r\n            },\r\n        'slave': {\r\n            'url': 'mysql://username:password@127.0.0.1:3306/dbname?charset=utf8',\r\n            'echo': False,\r\n            },\r\n        'user.master': {\r\n            'url': 'mysql://username:password@127.0.0.1:3306/dbname?charset=utf8',\r\n            'echo': False,\r\n            },\r\n        'user.slave': {\r\n            'url': 'mysql://username:password@127.0.0.1:3306/dbname?charset=utf8',\r\n            'echo': False,\r\n            },\r\n        'article.sharding1': {\r\n            'url': 'mysql://username:password@127.0.0.1:3306/dbname?charset=utf8',\r\n            'echo': False,\r\n            },\r\n        'article.sharding2': {\r\n            'url': 'mysql://username:password@127.0.0.1:3306/dbname?charset=utf8',\r\n            'echo': False,\r\n            },\r\n    }\r\n```\r\n\r\narticle model's implementation\r\n\r\n```\r\nimport thing\r\n\r\nclass Article(thing.Thing):\r\n    def sharding_strategy(self):\r\n        if self.id % 2 == 0:\r\n            return 'sharding1'\r\n        else:\r\n            return 'sharding2'\r\n```\r\n\r\n* user model's db write operation will go to `user.master` section, read go to `user.slave`\r\n* article model's id is even, go to sharding1 else go to sharding2\r\n* comment model's db write operation will go to `master` section, read go to `slave`","tagline":"lightweight SQLAlchemy based ORM","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}